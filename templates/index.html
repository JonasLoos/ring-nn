<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Training Log Visualization</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-3.0.1.min.js" charset="utf-8"></script>
    <style>
body { padding-top: 20px; }
.plot-container { margin-bottom: 30px; }
.controls { margin-bottom: 20px; }
#gradient-plot-container { height: 500px; }
.axis-label-input {
    width: 150px;
    margin-left: 5px;
    margin-right: 15px;
}
#gradient-explorer-controls {
    position: sticky;
    top: 0;
    z-index: 100;
    background: white;
}
    </style>
</head>
<body>
    <div class="container-fluid">
        <h1 class="text-center">Training Log Visualization</h1>

        <div class="form-group controls row">
            <div class="col-md-4">
                <label for="log-file-select">Select Log File:</label>
                <select id="log-file-select" class="form-control"></select>
            </div>
        </div>

        <div id="loading-message" class="alert alert-info">Loading data...</div>
        <div id="error-message" class="alert alert-danger" style="display: none;"></div>

        <div id="dashboard-content" style="display: none;">
            <!-- Overview Plots -->
            <div class="row">
                <div class="col-md-6">
                    <h3 class="text-center">Training Loss</h3>
                    <div id="loss-plot" class="plot-container"></div>
                </div>
                <div class="col-md-6">
                    <h3 class="text-center">Training Accuracy</h3>
                    <div id="accuracy-plot" class="plot-container"></div>
                </div>
            </div>
            <div class="row">
                <div class="col-md-6">
                    <h3 class="text-center">Learning Rate</h3>
                    <div id="lr-plot" class="plot-container"></div>
                </div>
                <div class="col-md-6">
                    <h3 class="text-center">Average Update Ratio</h3>
                    <div id="update-ratio-plot" class="plot-container"></div>
                </div>
            </div>

            <hr>

            <!-- Interactive Gradient Exploration -->
            <h2 class="text-center">Gradient Explorer</h2>
            <div class="controls row" id="gradient-explorer-controls">
                <div class="col-md-3">
                    <label for="epoch-slider">Epoch:</label>
                    <input type="range" id="epoch-slider" class="form-control-range" min="0" max="0" step="1" value="0">
                    <span id="epoch-value">Epoch: 0</span>
                </div>
                <div class="col-md-3">
                    <label for="batch-slider">Batch:</label>
                    <input type="range" id="batch-slider" class="form-control-range" min="0" max="0" step="1" value="0">
                    <span id="batch-value">Batch: 0</span>
                </div>
                <div class="col-md-3">
                    <label for="layer-select">Layer:</label>
                    <select id="layer-select" class="form-control"></select>
                </div>
                 <div class="col-md-3">
                    <label for="value-type-select">Value Type:</label>
                    <select id="value-type-select" class="form-control">
                        <option value="weights">Weights</option>
                        <option value="updates_final">Gradient Updates (Final)</option>
                        <option value="updates_float">Gradient Updates (Float)</option>
                    </select>
                </div>
            </div>
            <div class="row">
                <div class="col-md-12">
                    <div id="gradient-plot-container" class="plot-container"></div>
                </div>
            </div>
             <div class="row controls">
                <div class="col-md-12">
                    <p><strong>Weight/Gradient Value at selected coordinate:</strong> <span id="selected-gradient-value">N/A</span></p>
                    <p>Select x, y, (z) axis for the heatmap. For 2D weights, only x and y are used. For 1D, only x.</p>
                    <label for="dim-x-select">X-axis:</label>
                    <select id="dim-x-select" class="form-control-sm"></select>
                    <label for="dim-y-select">Y-axis:</label>
                    <select id="dim-y-select" class="form-control-sm"></select>
                    <label for="dim-z-select">Z-axis (for slicing >2D data):</label>
                    <select id="dim-z-select" class="form-control-sm"></select>
                    <input type="number" id="z-slice-input" class="form-control-sm" value="0" title="Slice index for Z-axis">
                </div>
            </div>

            <hr>

            <!-- Weight/Update Distribution Histogram -->
            <h2 class="text-center">Weight/Update Distribution</h2>
            <p class="text-center">Uses the same Epoch, Batch, Layer, and Value Type selections from the Gradient Explorer above.</p>
            <div class="row">
                <div class="col-md-12">
                    <div id="distribution-histogram-plot" class="plot-container" style="height: 400px;"></div>
                </div>
            </div>

            <hr>

            <!-- Parameter Value Evolution -->
            <h2 class="text-center">Parameter Value Evolution</h2>
            <p class="text-center">Click on a cell in the Gradient Explorer heatmap to select a parameter. The plot below will show its value (or its update's value) over all iterations.</p>
            <div class="row controls">
                <div class="col-md-12">
                    <p><strong>Tracking Parameter:</strong> <span id="tracked-parameter-info">Nothing selected. Click on the heatmap above.</span></p>
                </div>
            </div>
            <div class="row">
                <div class="col-md-12">
                    <div id="parameter-evolution-plot" class="plot-container" style="height: 400px;"></div>
                </div>
            </div>

            <hr>

            <!-- Weight Feature Visualization -->
            <h2 class="text-center">Weight Feature Visualization</h2>
            <p class="text-center">Visualizes features (e.g., columns of a weight matrix, reshaped into squares like 28x28, or kernels from a 3D/4D tensor)
                                   from the selected layer's weights. Uses Epoch, Batch, and Layer from Gradient Explorer. Only for 'Weights' value type.
                                   Shows absolute values on a 'Greys' colorscale.
            </p>
            <div class="row">
                <div class="col-md-12">
                    <div id="weight-feature-plot" class="plot-container" style="height: 500px;"></div>
                </div>
            </div>

        </div>
    </div>

    <script>
        let trainLogs = [];
        let uniqueEpochs = [];
        let batchesPerEpoch = {}; // Stores how many batches are in each epoch
        let maxBatches = 0; // Max batches in any epoch, for slider
        let trackedParameterPath = null; // { layerIndex, valueType, indexPath: [idx1, idx2...] }
        let availableLogFiles = [];
        let currentLogFile = null;

        document.addEventListener('DOMContentLoaded', async () => {
            await loadLogFilesList();
            const logFileSelect = document.getElementById('log-file-select');
            logFileSelect.addEventListener('change', async (event) => {
                currentLogFile = event.target.value;
                await loadDataAndRender(currentLogFile);
            });

            if (availableLogFiles.length > 0) {
                currentLogFile = availableLogFiles[0];
                logFileSelect.value = currentLogFile;
                await loadDataAndRender(currentLogFile);
            } else {
                document.getElementById('loading-message').textContent = 'No log files found in logs/ directory.';
                document.getElementById('error-message').style.display = 'none';
            }
        });

        async function loadLogFilesList() {
            try {
                const response = await fetch('/list-logs');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                availableLogFiles = await response.json();
                const logFileSelect = document.getElementById('log-file-select');
                logFileSelect.innerHTML = ''; // Clear existing options
                if (availableLogFiles.length > 0) {
                    availableLogFiles.forEach(fileName => {
                        const option = document.createElement('option');
                        option.value = fileName;
                        option.textContent = fileName;
                        logFileSelect.appendChild(option);
                    });
                } else {
                    const option = document.createElement('option');
                    option.textContent = "No log files found";
                    option.disabled = true;
                    logFileSelect.appendChild(option);
                }
            } catch (error) {
                console.error('Error fetching log files list:', error);
                document.getElementById('loading-message').style.display = 'none';
                const errorDiv = document.getElementById('error-message');
                errorDiv.textContent = `Error fetching log files list: ${error.message}`;
                errorDiv.style.display = 'block';
                availableLogFiles = [];
            }
        }

        async function loadDataAndRender(logFileName) {
            if (!logFileName) {
                document.getElementById('loading-message').textContent = 'Please select a log file.';
                document.getElementById('dashboard-content').style.display = 'none';
                return;
            }

            document.getElementById('loading-message').textContent = `Loading data from ${logFileName}...`;
            document.getElementById('loading-message').style.display = 'block';
            document.getElementById('dashboard-content').style.display = 'none';
            document.getElementById('error-message').style.display = 'none';
            trackedParameterPath = null; // Reset tracked parameter on new file load

            try {
                const response = await fetch(`/data?log_file=${encodeURIComponent(logFileName)}`);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                }
                trainLogs = await response.json();

                if (!trainLogs || trainLogs.length === 0) {
                    document.getElementById('loading-message').textContent = `No training data found in ${logFileName}.`;
                    return;
                }

                document.getElementById('loading-message').style.display = 'none';
                document.getElementById('dashboard-content').style.display = 'block';

                // Reset and Process data for selectors and plot ranges
                const epochs = new Set();
                batchesPerEpoch = {};
                trainLogs.forEach(log => {
                    epochs.add(log.epoch);
                    if (!batchesPerEpoch[log.epoch]) {
                        batchesPerEpoch[log.epoch] = 0;
                    }
                    batchesPerEpoch[log.epoch]++;
                });
                uniqueEpochs = Array.from(epochs).sort((a, b) => a - b);
                maxBatches = Math.max(0, ...Object.values(batchesPerEpoch)) -1; // Max batches in any epoch, 0-indexed
                if (Object.keys(batchesPerEpoch).length === 0) maxBatches = -1; // Handle case with no batches

                // Clear previous plot states if necessary
                Plotly.purge('loss-plot');
                Plotly.purge('accuracy-plot');
                Plotly.purge('lr-plot');
                Plotly.purge('update-ratio-plot');
                Plotly.purge('gradient-plot-container');
                Plotly.purge('distribution-histogram-plot');
                Plotly.purge('parameter-evolution-plot');
                Plotly.purge('weight-feature-plot');
                document.getElementById('layer-select').innerHTML = ''; // Clear layer select
                document.getElementById('dim-x-select').innerHTML = '';
                document.getElementById('dim-y-select').innerHTML = '';
                document.getElementById('dim-z-select').innerHTML = '';

                plotOverviewCharts();
                setupGradientExplorer(); // This will re-populate layer select and sliders
                plotGradientHeatmap(); // Initial plot
                plotDistributionHistogram(); // Initial plot
                plotParameterEvolution(); // Initial (empty) plot
                plotWeightFeatureVisualizations(); // Initial plot for weight features

            } catch (error) {
                console.error('Error loading or processing data:', error);
                document.getElementById('loading-message').style.display = 'none';
                const errorDiv = document.getElementById('error-message');
                errorDiv.textContent = `Error loading data from ${logFileName}: ${error.message}`;
                errorDiv.style.display = 'block';
                trainLogs = []; // Clear data if error
            }
        }

        function getLogEntry(epoch, batch_idx_in_epoch) {
            return trainLogs.find(log => log.epoch === epoch && log.i === batch_idx_in_epoch);
        }

        function plotOverviewCharts() {
            const iterations = Array.from({ length: trainLogs.length }, (_, i) => i);
            const losses = trainLogs.map(log => log.loss);
            const accuracies = trainLogs.map(log => log.accuracy);
            const lrs = trainLogs.map(log => log.lr);
            const updateRatios = trainLogs.map(log =>
                log.abs_update_float > 0 ? log.abs_update_final / log.abs_update_float : 0
            );

            Plotly.newPlot('loss-plot', [{
                x: iterations,
                y: losses,
                type: 'scatter',
                mode: 'lines',
                name: 'Loss'
            }], { title: 'Training Loss vs. Iteration', xaxis: {title: 'Iteration'}, yaxis: {title: 'Loss'} });

            Plotly.newPlot('accuracy-plot', [{
                x: iterations,
                y: accuracies,
                type: 'scatter',
                mode: 'lines',
                name: 'Accuracy'
            }], { title: 'Training Accuracy vs. Iteration', xaxis: {title: 'Iteration'}, yaxis: {title: 'Accuracy', tickformat: '.0%'} });

            Plotly.newPlot('lr-plot', [{
                x: iterations,
                y: lrs,
                type: 'scatter',
                mode: 'lines',
                name: 'Learning Rate'
            }], { title: 'Learning Rate vs. Iteration', xaxis: {title: 'Iteration'}, yaxis: {title: 'Learning Rate', type: 'log'} });

            Plotly.newPlot('update-ratio-plot', [{
                x: iterations,
                y: updateRatios,
                type: 'scatter',
                mode: 'lines',
                name: 'Update Ratio (Final/Float)'
            }], { title: 'Avg. Update Ratio vs. Iteration', xaxis: {title: 'Iteration'}, yaxis: {title: 'abs_update_final / abs_update_float', type: 'log'} });
        }

        function setupGradientExplorer() {
            const epochSlider = document.getElementById('epoch-slider');
            const epochValueSpan = document.getElementById('epoch-value');
            const batchSlider = document.getElementById('batch-slider');
            const batchValueSpan = document.getElementById('batch-value');
            const layerSelect = document.getElementById('layer-select');
            const valueTypeSelect = document.getElementById('value-type-select');
            const dimXSelect = document.getElementById('dim-x-select');
            const dimYSelect = document.getElementById('dim-y-select');
            const dimZSelect = document.getElementById('dim-z-select');
            const zSliceInput = document.getElementById('z-slice-input');
            const gradientPlotDiv = document.getElementById('gradient-plot-container');

            // Initialize the gradient plot container as an empty Plotly graph
            // so that Plotly methods like .on() are available on the div.
            Plotly.newPlot(gradientPlotDiv, [], {}, {staticPlot: true}); // staticPlot true for empty init

            // Clear previous layer options before populating for new data
            layerSelect.innerHTML = '';

            if (uniqueEpochs.length > 0) {
                epochSlider.min = uniqueEpochs[0];
                epochSlider.max = uniqueEpochs[uniqueEpochs.length - 1];
                epochSlider.value = uniqueEpochs[0];
                epochValueSpan.textContent = `Epoch: ${uniqueEpochs[0]}`;

                batchSlider.min = 0;
                batchSlider.max = maxBatches >= 0 ? (batchesPerEpoch[uniqueEpochs[0]] -1) : 0;
                batchSlider.value = 0;
                batchValueSpan.textContent = `Batch: 0/${maxBatches >=0 ? (batchesPerEpoch[uniqueEpochs[0]] -1) : 0}`;
            } else {
                epochSlider.min = 0;
                epochSlider.max = 0;
                epochSlider.value = 0;
                epochValueSpan.textContent = `Epoch: N/A`;
                batchSlider.min = 0;
                batchSlider.max = 0;
                batchSlider.value = 0;
                batchValueSpan.textContent = `Batch: N/A`;
            }

            // const firstLog = trainLogs[0];
            // Get the first log entry of the *currently loaded* trainLogs
            const firstLog = trainLogs && trainLogs.length > 0 ? getLogEntry(uniqueEpochs[0], 0) : null;

            if (firstLog && firstLog.weights) {
                firstLog.weights.forEach((_, i) => {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `Layer ${i}`;
                    layerSelect.appendChild(option);
                });
            }

            epochSlider.addEventListener('input', (e) => {
                const selectedEpoch = parseInt(e.target.value);
                epochValueSpan.textContent = `Epoch: ${selectedEpoch}`;
                const numBatchesInEpoch = batchesPerEpoch[selectedEpoch] ? batchesPerEpoch[selectedEpoch] -1 : 0;
                batchSlider.max = numBatchesInEpoch;
                if (parseInt(batchSlider.value) > numBatchesInEpoch) {
                    batchSlider.value = numBatchesInEpoch;
                }
                batchValueSpan.textContent = `Batch: ${batchSlider.value}/${numBatchesInEpoch}`;
                plotGradientHeatmap();
                plotDistributionHistogram();
                plotWeightFeatureVisualizations();
            });

            batchSlider.addEventListener('input', (e) => {
                const selectedEpoch = parseInt(epochSlider.value);
                const numBatchesInEpoch = batchesPerEpoch[selectedEpoch] ? batchesPerEpoch[selectedEpoch] -1 : 0;
                batchValueSpan.textContent = `Batch: ${e.target.value}/${numBatchesInEpoch}`;
                plotGradientHeatmap();
                plotDistributionHistogram();
                plotWeightFeatureVisualizations();
            });

            layerSelect.addEventListener('change', () => {
                plotGradientHeatmap();
                plotDistributionHistogram();
                plotWeightFeatureVisualizations();
            });
            valueTypeSelect.addEventListener('change', () => {
                plotGradientHeatmap();
                plotDistributionHistogram();
                plotWeightFeatureVisualizations(); // Update feature viz based on value type
                if (trackedParameterPath) { // If a parameter is being tracked, update its evolution plot for the new value type
                    trackedParameterPath.valueType = document.getElementById('value-type-select').value;
                    plotParameterEvolution();
                     document.getElementById('tracked-parameter-info').textContent =
                        `Layer: ${trackedParameterPath.layerIndex}, Type: ${trackedParameterPath.valueType}, Path: [${trackedParameterPath.indexPath.join(', ')}]`;
                }
            });
            dimXSelect.addEventListener('change', plotGradientHeatmap);
            dimYSelect.addEventListener('change', plotGradientHeatmap);
            dimZSelect.addEventListener('change', plotGradientHeatmap);
            zSliceInput.addEventListener('change', plotGradientHeatmap);

            gradientPlotDiv.on('plotly_click', function(data){
                if (data.points.length > 0) {
                    const point = data.points[0];
                    const zValue = point.z;
                    // point.x and point.y are the string labels of the axes if they exist, or indices if not.
                    // We need the actual indices into the potentially multi-dimensional array.
                    // The current plotGradientHeatmap logic ensures x, y, z, and slice dimensions are handled.
                    // We need to reconstruct the full path to the selected element based on current dim selections.

                    const xDim = parseInt(document.getElementById('dim-x-select').value) || 0;
                    const yDim = parseInt(document.getElementById('dim-y-select').value) || 0;
                    const zDim = parseInt(document.getElementById('dim-z-select').value) || 0; // Slicing dim
                    const zSliceIdx = parseInt(document.getElementById('z-slice-input').value) || 0;

                    const layerIndex = parseInt(document.getElementById('layer-select').value);
                    const currentEpoch = parseInt(document.getElementById('epoch-slider').value);
                    const currentBatchIdx = parseInt(document.getElementById('batch-slider').value);
                    const currentValueType = document.getElementById('value-type-select').value;
                    const logEntry = getLogEntry(currentEpoch, currentBatchIdx);
                    const fullDataArray = logEntry[currentValueType][layerIndex];
                    const shape = getArrayShape(fullDataArray);

                    let clickedIndexPath = Array(shape.length).fill(0);

                    // Determine the actual indices based on the clicked heatmap cell
                    // Heatmap gives x,y coordinates which correspond to the *displayed* 2D slice.
                    // We need to map these back to the original tensor dimensions.
                    const xIndex = parseInt(point.x); // Index along the displayed X-axis
                    const yIndex = parseInt(point.y); // Index along the displayed Y-axis

                    if (shape.length === 0) { // Scalar
                         clickedIndexPath = [];
                    } else if (shape.length === 1) {
                        clickedIndexPath[xDim] = xIndex;
                    } else if (shape.length === 2) {
                        const currentXDimOnHeatmap = (document.getElementById('dim-x-select').value == 1 && document.getElementById('dim-y-select').value == 0) ? 1 : 0;
                        const currentYDimOnHeatmap = (document.getElementById('dim-x-select').value == 1 && document.getElementById('dim-y-select').value == 0) ? 0 : 1;

                        clickedIndexPath[currentXDimOnHeatmap] = xIndex;
                        clickedIndexPath[currentYDimOnHeatmap] = yIndex;
                    } else { // > 2D, sliced
                        clickedIndexPath[xDim] = xIndex;
                        clickedIndexPath[yDim] = yIndex;
                        clickedIndexPath[zDim] = zSliceIdx;
                        // Other dimensions are implicitly 0 as per plotGradientHeatmap logic
                    }

                    trackedParameterPath = {
                        layerIndex: layerIndex,
                        valueType: currentValueType,
                        indexPath: clickedIndexPath,
                        shape: shape // Store shape for context
                    };

                    const xCoordDisplay = point.x;
                    const yCoordDisplay = point.y;
                    document.getElementById('selected-gradient-value').textContent =
                        `${zValue.toExponential(3)} at displayed (x=${xCoordDisplay}, y=${yCoordDisplay}). Path: [${clickedIndexPath.join(', ')}]`;

                    document.getElementById('tracked-parameter-info').textContent =
                        `Layer: ${layerIndex}, Type: ${currentValueType}, Path: [${clickedIndexPath.join(', ')}]`;

                    plotParameterEvolution();
                }
            });
        }

        function getArrayShape(arr) {
            if (!Array.isArray(arr)) return [];
            const shape = [];
            let current = arr;
            while (Array.isArray(current)) {
                shape.push(current.length);
                current = current[0];
                if (shape.length > 10) break; // Safety break for very deep or non-uniform arrays
            }
            return shape;
        }

        // Helper to get a value from a potentially nested array using a path of indices
        function getNestedValue(arr, pathIndices) {
            let val = arr;
            for (const index of pathIndices) {
                if (val === undefined || !Array.isArray(val) || index >= val.length) return undefined;
                val = val[index];
            }
            return val;
        }

        function reshape(arr, rows, cols) {
            if (!arr || arr.length !== rows * cols) {
                // console.warn(`Reshape failed: array length ${arr?.length} vs ${rows*cols}`);
                return null;
            }
            const newArr = [];
            for (let r = 0; r < rows; r++) {
                newArr.push(arr.slice(r * cols, (r + 1) * cols));
            }
            return newArr;
        }

        function plotGradientHeatmap() {
            const epoch = parseInt(document.getElementById('epoch-slider').value);
            const batchIdx = parseInt(document.getElementById('batch-slider').value);
            const layerIndex = parseInt(document.getElementById('layer-select').value);
            const valueType = document.getElementById('value-type-select').value; // 'weights', 'updates_final', 'updates_float'

            const logEntry = getLogEntry(epoch, batchIdx);
            if (!logEntry || !logEntry[valueType] || !logEntry[valueType][layerIndex]) {
                Plotly.purge('gradient-plot-container');
                document.getElementById('gradient-plot-container').innerHTML = '<div class="alert alert-warning">Data not available for this selection.</div>';
                document.getElementById('selected-gradient-value').textContent = 'N/A';
                return;
            }

            let dataToPlot = logEntry[valueType][layerIndex];
            const shape = getArrayShape(dataToPlot);

            const dimXSelect = document.getElementById('dim-x-select');
            const dimYSelect = document.getElementById('dim-y-select');
            const dimZSelect = document.getElementById('dim-z-select');
            const zSliceInput = document.getElementById('z-slice-input');

            // Populate dimension selectors if not already populated or if shape changed
            // Only repopulate if the number of dimensions has changed significantly, or if empty
            let needsRepopulate = dimXSelect.options.length === 0;
            if (!needsRepopulate && dimXSelect.options.length > 0 && shape.length > 0 && dimXSelect.options[0]) {
                const firstOption = dimXSelect.options[0];
                // Check if the first option is not representing Dim 0 or if its stored size doesn't match current shape[0]
                if (parseInt(firstOption.value) !== 0 || !firstOption.textContent.includes(`(size ${shape[0]})`)) {
                    needsRepopulate = true;
                }
            }
            // Also, if the total number of options doesn't match the current number of dimensions, repopulate.
            if (dimXSelect.options.length !== shape.length) { // True if shape.length is 0 and options exist, or if they differ
                 needsRepopulate = true;
            }

            if (needsRepopulate) {
                [dimXSelect, dimYSelect, dimZSelect].forEach(selectEl => selectEl.innerHTML = ''); // Use selectEl and clear
                if (shape.length > 0) {
                    shape.forEach((dimSize, i) => {
                        [dimXSelect, dimYSelect, dimZSelect].forEach(selectEl => { // Use selectEl
                            const opt = document.createElement('option');
                            opt.value = i; // Dimension index
                            opt.textContent = `Dim ${i} (size ${dimSize})`;
                            selectEl.appendChild(opt);
                        });
                    });

                    // Set default selections
                    if (dimXSelect.options.length > 0) dimXSelect.value = "0";

                    if (shape.length > 1 && dimYSelect.options.length >= 2) {
                        dimYSelect.value = "1";
                    } else if (dimYSelect.options.length > 0) {
                        dimYSelect.value = dimYSelect.options[0].value;
                    }

                    if (shape.length > 2 && dimZSelect.options.length >= 3) {
                        dimZSelect.value = "2";
                    } else if (dimZSelect.options.length > 0) {
                        dimZSelect.value = dimZSelect.options[0].value;
                    }
                } // else, if shape.length is 0, selectors remain empty
            }

            dimYSelect.disabled = shape.length < 2;
            dimZSelect.disabled = shape.length < 3;
            zSliceInput.disabled = shape.length < 3;

            let xDim = parseInt(dimXSelect.value) || 0;
            let yDim = shape.length > 1 ? (parseInt(dimYSelect.value) || 1) : -1; // -1 if no yDim
            let zDim = shape.length > 2 ? (parseInt(dimZSelect.value) || 2) : -1; // -1 if no zDim (slicing dim)
            let zSliceIdx = shape.length > 2 ? parseInt(zSliceInput.value) : 0;

            // Ensure selected dims are unique and valid
            const selectedDims = new Set();
            if (xDim >=0 && xDim < shape.length) selectedDims.add(xDim);
            if (yDim >=0 && yDim < shape.length) selectedDims.add(yDim);
            if (zDim >=0 && zDim < shape.length && shape.length > 2) selectedDims.add(zDim);

            if ((shape.length === 1 && selectedDims.size !== 1) ||
                (shape.length === 2 && selectedDims.size !== 2 && new Set([xDim,yDim]).size !== 2) ||
                (shape.length > 2 && selectedDims.size !== 3 && new Set([xDim,yDim, zDim]).size !== 3)) {
                // Reset to default if invalid selection due to dynamic changes
                xDim = 0;
                yDim = shape.length > 1 ? 1 : -1;
                zDim = shape.length > 2 ? 2 : -1;
                if (dimXSelect.options.length > 0) dimXSelect.value = xDim;
                if (dimYSelect.options.length > 1 && yDim !== -1) dimYSelect.value = yDim;
                else if (dimYSelect.options.length > 0) dimYSelect.value = dimYSelect.options[0].value;
                if (dimZSelect.options.length > 2 && zDim !== -1) dimZSelect.value = zDim;
                else if (dimZSelect.options.length > 0) dimZSelect.value = dimZSelect.options[0].value;
            }

            zSliceInput.max = (zDim !== -1 && shape[zDim] > 0) ? shape[zDim] - 1 : 0;
            if (zSliceIdx > parseInt(zSliceInput.max)) {
                zSliceIdx = parseInt(zSliceInput.max);
                zSliceInput.value = zSliceIdx;
            }

            let heatmapData, xLabels, yLabels, title;
            const valueTypeDisplay = document.getElementById('value-type-select').selectedOptions[0].text;
            title = `${valueTypeDisplay} - Layer ${layerIndex} - Epoch ${epoch}, Batch ${batchIdx}`;

            if (shape.length === 0) { // Scalar
                heatmapData = [[dataToPlot]];
                xLabels = ['0'];
                yLabels = ['0'];
                title += ` (Scalar Value: ${dataToPlot.toExponential(3)})`;
            } else if (shape.length === 1) { // 1D array (vector)
                heatmapData = [dataToPlot]; // Plotly heatmap wants 2D array
                xLabels = Array.from({ length: shape[0] }, (_, i) => i.toString());
                yLabels = ['0']; // Single row
                title += ` (Vector, Dim ${xDim})`;
            } else if (shape.length === 2) { // 2D array (matrix)
                // Transpose if xDim is 1 and yDim is 0
                const actualXDim = xDim; // The dimension index to iterate for x-axis values
                const actualYDim = yDim; // The dimension index to iterate for y-axis values

                if (xDim === 1 && yDim === 0) { // User wants to swap displayed axes for a 2D array
                    heatmapData = dataToPlot[0].map((_, colIndex) => dataToPlot.map(row => row[colIndex]));
                    xLabels = Array.from({ length: shape[1] }, (_, i) => i.toString()); // Original dim 1 is now x-axis
                    yLabels = Array.from({ length: shape[0] }, (_, i) => i.toString()); // Original dim 0 is now y-axis
                } else { // Default: xDim=0, yDim=1 (or user selected them in this order)
                    heatmapData = dataToPlot;
                    xLabels = Array.from({ length: shape[actualXDim === 0 ? shape[1] : shape[0]] }, (_, i) => i.toString());
                    yLabels = Array.from({ length: shape[actualXDim === 0 ? shape[0] : shape[1]] }, (_, i) => i.toString());
                }
                title += ` (Matrix, X:Dim ${xDim}, Y:Dim ${yDim})`;
            } else { // >2D array, slice it
                title += ` (Sliced >2D Tensor, X:Dim ${xDim}, Y:Dim ${yDim}, SliceDim:${zDim}@${zSliceIdx})`;
                const fixedDims = []; // Dims not used for x, y, or slicing
                for(let i=0; i<shape.length; i++) {
                    if (i !== xDim && i !== yDim && i !== zDim) {
                        fixedDims.push(i);
                    }
                }

                // This part is tricky: we need to extract a 2D slice
                // based on xDim, yDim, zDim, and zSliceIdx.
                // The remaining dimensions are effectively fixed at index 0 for this visualization.
                // A more robust slicer would allow controlling all fixed_dims indices.

                const xSize = shape[xDim];
                const ySize = shape[yDim];
                heatmapData = Array(ySize).fill(null).map(() => Array(xSize).fill(0));

                // Create a template path of indices, e.g., [0,0,0,...]
                const indexPath = Array(shape.length).fill(0);
                indexPath[zDim] = zSliceIdx; // Set the slice index for the z-dimension

                for (let yi = 0; yi < ySize; yi++) {
                    for (let xi = 0; xi < xSize; xi++) {
                        indexPath[xDim] = xi;
                        indexPath[yDim] = yi;
                        // For other dimensions not x,y,z, we keep them at 0 for simplicity
                        // A more complex UI could allow setting these.
                        heatmapData[yi][xi] = getNestedValue(dataToPlot, indexPath);
                    }
                }
                xLabels = Array.from({ length: xSize }, (_, i) => i.toString());
                yLabels = Array.from({ length: ySize }, (_, i) => i.toString());
            }

            const plotData = [{
                z: heatmapData,
                x: xLabels,
                y: yLabels,
                type: 'heatmap',
                colorscale: 'Viridis',
                reversescale: true,
                transpose: shape.length === 1 // For 1D, data is [values], y is '0', looks better transposed
            }];

            const layout = {
                title: title,
                xaxis: { title: `Displayed X-Dimension (Orig Dim ${xDim}${shape.length > 0 ? ', Size '+shape[xDim] : ''})` },
                yaxis: { title: `Displayed Y-Dimension (Orig Dim ${yDim}${shape.length > 1 ? ', Size '+shape[yDim] : ''})` , autorange: 'reversed'},
                // autosize: true, // this can sometimes fight with fixed height container
                height: document.getElementById('gradient-plot-container').clientHeight || 500
            };

            Plotly.react('gradient-plot-container', plotData, layout);
        }

        function plotDistributionHistogram() {
            const epoch = parseInt(document.getElementById('epoch-slider').value);
            const batchIdx = parseInt(document.getElementById('batch-slider').value);
            const layerIndex = parseInt(document.getElementById('layer-select').value);
            const valueType = document.getElementById('value-type-select').value;
            const histogramPlotDiv = document.getElementById('distribution-histogram-plot');

            const logEntry = getLogEntry(epoch, batchIdx);

            if (!logEntry || !logEntry[valueType] || !logEntry[valueType][layerIndex]) {
                Plotly.purge(histogramPlotDiv);
                histogramPlotDiv.innerHTML = '<div class="alert alert-warning">Data not available for histogram.</div>';
                return;
            }

            let dataForHist = logEntry[valueType][layerIndex];

            // Flatten the array for the histogram
            function flatten(arr) {
                return arr.reduce((acc, val) => Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), []);
            }

            const flatData = Array.isArray(dataForHist) ? flatten(dataForHist) : [dataForHist]; // Handle scalar case too

            const trace = {
                x: flatData,
                type: 'histogram',
                marker: {
                    color: 'rgba(100, 200, 102, 0.7)',
                },
            };
            const valueTypeDisplay = document.getElementById('value-type-select').selectedOptions[0].text;
            const layout = {
                title: `Distribution of ${valueTypeDisplay} - Layer ${layerIndex} (Epoch ${epoch}, Batch ${batchIdx})`,
                xaxis: { title: 'Value' },
                yaxis: { title: 'Frequency' },
                bargap: 0.05
            };

            Plotly.react(histogramPlotDiv, [trace], layout);
        }

        function plotParameterEvolution() {
            const evolutionPlotDiv = document.getElementById('parameter-evolution-plot');

            if (!trackedParameterPath) {
                Plotly.purge(evolutionPlotDiv);
                evolutionPlotDiv.innerHTML = '<div class="alert alert-info">Click on a cell in the Gradient Explorer heatmap above to track a parameter.</div>';
                return;
            }
            const { layerIndex, valueType, indexPath, shape } = trackedParameterPath;
            const valuesOverTime = [];
            const iterations = [];

            for (let i = 0; i < trainLogs.length; i++) {
                const log = trainLogs[i];
                if (log[valueType] && log[valueType][layerIndex]) {
                    const dataArray = log[valueType][layerIndex];
                    const currentShape = getArrayShape(dataArray);
                    let shapeMatch = shape.length === currentShape.length;
                    if(shapeMatch && shape.length > 0) {
                        for(let d=0; d<shape.length; d++) {
                            if(shape[d] !== currentShape[d]) {
                                shapeMatch = false;
                                break;
                            }
                        }
                    }

                    if (shapeMatch) {
                        const val = getNestedValue(dataArray, indexPath);
                        if (val !== undefined) {
                            valuesOverTime.push(val);
                            iterations.push(i);
                        }
                    } else {
                        // console.warn(`Shape mismatch for tracked parameter at iteration ${i}. Expected ${shape}, got ${currentShape}`);
                    }
                }
            }

            if (valuesOverTime.length === 0) {
                Plotly.purge(evolutionPlotDiv);
                evolutionPlotDiv.innerHTML = '<div class="alert alert-warning">Could not retrieve evolution data for the selected parameter. Its shape might have changed or it wasn\'t available across all logs.</div>';
                return;
            }

            const valueTypeDisplay = document.getElementById('value-type-select').selectedOptions[0].text;
            const trace = {
                x: iterations,
                y: valuesOverTime,
                type: 'scatter',
                mode: 'lines+markers',
                name: `Layer ${layerIndex} - Path [${indexPath.join(', ')}]`
            };

            const layout = {
                title: `Evolution of ${valueTypeDisplay} for Layer ${layerIndex}, Path [${indexPath.join(', ')}]`,
                xaxis: { title: 'Global Training Iteration' },
                yaxis: { title: 'Parameter Value / Update Value' }
            };

            Plotly.react(evolutionPlotDiv, [trace], layout);
        }

        function plotWeightFeatureVisualizations() {
            const featurePlotDiv = document.getElementById('weight-feature-plot');
            const epoch = parseInt(document.getElementById('epoch-slider').value);
            const batchIdx = parseInt(document.getElementById('batch-slider').value);
            const layerIndex = parseInt(document.getElementById('layer-select').value);
            const valueType = document.getElementById('value-type-select').value;

            if (valueType !== 'weights') {
                Plotly.purge(featurePlotDiv);
                featurePlotDiv.innerHTML = '<div class="alert alert-info">This visualization is only available for the "Weights" value type. Select "Weights" in the "Value Type" dropdown above.</div>';
                return;
            }

            const logEntry = getLogEntry(epoch, batchIdx);
            if (!logEntry || !logEntry.weights || !logEntry.weights[layerIndex]) {
                Plotly.purge(featurePlotDiv);
                featurePlotDiv.innerHTML = '<div class="alert alert-warning">Weight data not available for this selection.</div>';
                return;
            }

            let layerWeights = logEntry.weights[layerIndex];
            const shape = getArrayShape(layerWeights);
            let extractedFeatures = []; // Stores {data (1D for reshape) or data2D, title, imageSide}

            if (shape.length === 2) { // 2D array [dim0, dim1] -> dim1 features of length dim0
                const dim0 = shape[0]; // feature length
                const dim1 = shape[1]; // number of features
                const imageSide = Math.sqrt(dim0);
                if (Number.isInteger(imageSide) && imageSide > 0) {
                    for (let i = 0; i < Math.min(dim1, 10); i++) {
                        const column = layerWeights.map(row => Math.abs(row[i]));
                        extractedFeatures.push({data: column, title: `F${i}`, imageSide: imageSide});
                    }
                }
            } else if (shape.length === 1) { // 1D array [dim0] -> 1 feature if reshapeable
                const dim0 = shape[0];
                const imageSide = Math.sqrt(dim0);
                if (Number.isInteger(imageSide) && imageSide > 0) {
                     const absData = layerWeights.map(val => Math.abs(val));
                    extractedFeatures.push({data: absData, title: `Vector (abs val)`, imageSide: imageSide});
                }
            } else if (shape.length === 3) { // (num_filters, H, W)
                const numFilters = shape[0];
                const h = shape[1];
                const w = shape[2];
                if (h === w && h > 0) { // Square kernels/maps
                    for (let i = 0; i < Math.min(numFilters, 10); i++) {
                        if (layerWeights[i] && Array.isArray(layerWeights[i]) && Array.isArray(layerWeights[i][0])) {
                             const filter2D = layerWeights[i].map(row => row.map(val => Math.abs(val)));
                            extractedFeatures.push({data2D: filter2D, title: `Slc ${i} (abs val)`, imageSide: h});
                        }
                    }
                }
            } else if (shape.length === 4) { // (C_out, C_in, H, W)
                const cOut = shape[0];
                const cIn = shape[1];
                const h = shape[2];
                const w = shape[3];
                if (h === w && h > 0 && cIn > 0) { // Square kernels, at least one input channel
                    for (let i = 0; i < Math.min(cOut, 10); i++) {
                         // Visualize weights for the first input channel layerWeights[i][0]
                        if (layerWeights[i] && layerWeights[i][0] && Array.isArray(layerWeights[i][0]) && Array.isArray(layerWeights[i][0][0])) {
                            const filter2D = layerWeights[i][0].map(row => row.map(val => Math.abs(val)));
                            extractedFeatures.push({data2D: filter2D, title: `F${i}Ch0 (abs val)`, imageSide: h});
                        }
                    }
                }
            }

            if (extractedFeatures.length === 0) {
                Plotly.purge(featurePlotDiv);
                featurePlotDiv.innerHTML = '<div class="alert alert-warning">Selected layer weights are not in a recognized format for this feature grid visualization (e.g., 2D matrix with columns reshapeable to squares, or 3D/4D tensor with square kernels).</div>';
                return;
            }

            const traces = [];
            const layoutUpdates = {};
            const MAX_SUBPLOTS = 10;
            const numActualFeatures = Math.min(extractedFeatures.length, MAX_SUBPLOTS);

            const COLS = 5;
            const ROWS = Math.ceil(numActualFeatures / COLS);

            for(let k=0; k < numActualFeatures; k++) {
                const feature = extractedFeatures[k];
                let heatmapZ;

                if (feature.data2D) {
                    heatmapZ = feature.data2D; // Already 2D and abs values taken
                } else {
                    heatmapZ = reshape(feature.data, feature.imageSide, feature.imageSide); // feature.data already has abs values
                }

                if (!heatmapZ) continue; // Reshape failed or data unsuitable

                const axisNumber = k + 1;
                const xaxisName = 'x' + (axisNumber === 1 ? '' : axisNumber);
                const yaxisName = 'y' + (axisNumber === 1 ? '' : axisNumber);

                traces.push({
                    z: heatmapZ,
                    zmin: 0,
                    type: 'heatmap',
                    colorscale: 'Greys',
                    reversescale: false,
                    showscale: false,
                    xaxis: xaxisName,
                    yaxis: yaxisName,
                    hoverinfo: 'z+name',
                    name: feature.title,
                });
            }

            if (traces.length === 0) {
                 Plotly.purge(featurePlotDiv);
                 featurePlotDiv.innerHTML = '<div class="alert alert-warning">No features could be prepared for visualization after processing.</div>';
                 return;
            }

            const finalLayout = {
                title: `Weight Feature Visualization - Layer ${layerIndex} (Epoch ${epoch}, Batch ${batchIdx})`,
                grid: { rows: ROWS, columns: COLS, pattern: 'independent'},
                ...layoutUpdates,
                margin: { l: 25, r: 25, b: 25, t: 70, pad: 2 }, // Compact margins
                hovermode: 'closest'
            };
            // featurePlotDiv.style.height = `${ROWS * (extractedFeatures[0].imageSide * 3 + 40)}px`; // Optional: dynamic height adjustment

            Plotly.newPlot(featurePlotDiv, traces, finalLayout);
        }

    </script>
</body>
</html>